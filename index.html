<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>T-04: DNA-Based Storage System Simulation</title>
	<style>
		:root{
			--blue:#1a73e8; --blue-600:#155ab6; --red:#d93025; --green:#1e8e3e; --yellow:#f9ab00; --bg:#0b1020; --panel:#0f1630; --text:#e7ebff;
		}
		*{box-sizing:border-box}
		html,body{height:100%}
		body{
			font-family: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
			margin:0; background: radial-gradient(1200px 600px at 20% 10%, #1b2455 0%, #0b1020 60%), #0b1020; color:var(--text);
		}
		a{color:#9ec1ff}

		/* Layout */
			.container{max-width:1100px; margin:0 auto; padding:24px; position:relative; z-index:1; min-height:100vh; display:flex; align-items:center; justify-content:center}
			.card{background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03)); backdrop-filter: blur(6px);
				border:1px solid rgba(255,255,255,.16); border-radius:18px; padding:26px; box-shadow:0 20px 60px rgba(3,10,30,.45); width:100%}
		.hidden{display:none !important}
		h1{margin:0 0 10px; font-size:38px; line-height:1.2; font-weight:700}
		h2{margin:14px 0 8px}
		h3{margin:0 0 6px; font-size:16px; font-weight:600}
		.muted{color:#b9c3ff; opacity:.85}
		
		/* Hero title with logo */
		.hero-title{display:flex; align-items:center; justify-content:center; gap:16px; margin-bottom:12px}
		.hero-title h1{margin:0; font-size:48px; background:linear-gradient(135deg, #fff 0%, #a8c0ff 100%); -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text; letter-spacing:-0.5px; font-weight:800}
		.dna-logo{width:52px; height:52px; position:relative; animation:logoSpin 20s linear infinite}
		.dna-logo svg{width:100%; height:100%; filter:drop-shadow(0 4px 12px rgba(91,124,255,.4))}
		@keyframes logoSpin{ from{transform:rotateY(0deg)} to{transform:rotateY(360deg)} }

		/* Buttons */
		.btns{display:flex; gap:16px; flex-wrap:wrap; align-items:center; justify-content:center}
		button{
			align-items: center;
			background-image: linear-gradient(144deg, #af40ff, #5b42f3 50%, #00ddeb);
			border: 0;
			border-radius: 8px;
			box-shadow: rgba(151, 65, 252, 0.2) 0 15px 30px -5px;
			box-sizing: border-box;
			color: #ffffff;
			display: flex;
			font-size: 18px;
			justify-content: center;
			line-height: 1em;
			max-width: 100%;
			min-width: 140px;
			padding: 3px;
			text-decoration: none;
			user-select: none;
			-webkit-user-select: none;
			touch-action: manipulation;
			white-space: nowrap;
			cursor: pointer;
			transition: all 0.3s;
			font-weight: 500;
		}
		button:hover{outline: 0; transform:translateY(-2px); box-shadow: rgba(151, 65, 252, 0.4) 0 20px 40px -5px}
		button:active{transform: scale(0.9)}
		button span{
			background-color: rgb(5, 6, 45);
			padding: 16px 24px;
			border-radius: 6px;
			width: 100%;
			height: 100%;
			transition: 300ms;
		}
		button:hover span{background: none}
		button.primary{background-image: linear-gradient(144deg, #af40ff, #5b42f3 50%, #00ddeb)}
		button.secondary{background-image: linear-gradient(144deg, #4158d0, #5b7cff 50%, #00c9ff)}
		button.ghost{background-image: linear-gradient(144deg, #667eea, #764ba2 50%, #f093fb)}
		button:disabled{opacity:.6; cursor:not-allowed}

		/* Inputs */
		label{font-weight:600; display:block; margin-bottom:6px}
		textarea, input[type=text]{width:100%; padding:10px 12px; border:1px solid rgba(255,255,255,.15); background:#0c1330; color:var(--text); border-radius:10px; font-size:15px}
		textarea{min-height:90px; resize:vertical}
		.grid{display:grid; gap:12px}
		.grid.map{grid-template-columns:repeat(auto-fit,minmax(160px,1fr))}
		.map-item{display:flex; align-items:center; gap:10px}
		.base{width:34px; height:34px; border-radius:8px; color:#fff; display:grid; place-items:center; font-weight:800; box-shadow:0 6px 16px rgba(0,0,0,.35)}
		.A{background:var(--red)} .C{background:var(--green)} .G{background:var(--yellow); color:#222} .T{background:var(--blue)}

		/* Canvases */
		.viz-wrap{border:1px solid rgba(255,255,255,.12); border-radius:14px; background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02)); padding:12px; overflow:auto}
		canvas{display:block; max-width:100%}
		.legend{display:flex; gap:14px; flex-wrap:wrap; margin-top:8px; color:#c9d2ff; font-size:14px}
		.legend .chip{display:inline-flex; align-items:center; gap:6px}
		.legend .dot{width:14px; height:14px; border-radius:4px; display:inline-block}

		/* Intro DNA 3D animation */
			.intro{display:grid; gap:22px; align-items:center}
			.intro-center{min-height:calc(100vh - 96px); display:grid; place-items:center; text-align:center}
			/* Center all content vertically and horizontally */
			.intro-fill{display:flex; flex-direction:column; justify-content:center; align-items:center; text-align:center; padding:40px 20px}
			.intro-fill h1{margin-top:0}
			.intro-content{max-width:1000px; width:100%; margin:0 auto}
			.lead{max-width:820px; margin:0 auto 20px; line-height:1.7; font-size:18px}
			
			/* Feature grid */
			.feature-grid{display:grid; grid-template-columns:repeat(auto-fit, minmax(220px, 1fr)); gap:16px; margin:24px auto 20px; max-width:100%}
			.feature{background:rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.12); border-radius:14px; padding:18px; text-align:center; transition:.2s}
			.feature:hover{background:rgba(255,255,255,.08); border-color:rgba(255,255,255,.20)}
			.feature h3{margin:0 0 8px; font-size:17px; color:#fff}
			.feature p{margin:0; color:#c4d0ff; font-size:14px; line-height:1.6}
			.feature-icon{width:40px; height:40px; border-radius:10px; display:grid; place-items:center; margin:0 auto 12px; background:linear-gradient(135deg, #4158d0, #5b7cff); box-shadow:0 4px 12px rgba(65,88,208,.3)}
			.feature-icon svg{width:20px; height:20px; opacity:.95}
			
			/* Pills & legend */
			.pill-row{display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; margin:16px 0}
			.pill{display:inline-flex; align-items:center; gap:7px; padding:7px 13px; border-radius:999px; border:1px solid rgba(255,255,255,.20); background:rgba(255,255,255,.06); font-size:14px; font-weight:500}
			.dot{width:13px; height:13px; border-radius:4px; display:inline-block; box-shadow:0 2px 6px rgba(0,0,0,.25)}
			
			/* Divider */
			.divider{height:1px; background:linear-gradient(90deg, transparent, rgba(255,255,255,.15), transparent); margin:22px 0}
			
			/* Stats row */
			.stats-row{display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:14px; margin:20px auto; max-width:100%}
			.stat-card{background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.10); border-radius:12px; padding:14px; text-align:center}
			.stat-card strong{display:block; font-size:22px; color:#fff; margin-bottom:4px}
			.stat-card span{color:#b9c3ff; font-size:14px}
			
			/* Modal */
			.modal{position:fixed; inset:0; background:rgba(5,8,20,.85); backdrop-filter:blur(4px); display:grid; place-items:center; z-index:100; padding:20px}
			.modal-content{background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.05)); border:1px solid rgba(255,255,255,.20); border-radius:18px; padding:32px; max-width:800px; width:100%; max-height:85vh; overflow-y:auto; box-shadow:0 20px 60px rgba(0,0,0,.5)}
			.modal-header{display:flex; justify-content:space-between; align-items:center; margin-bottom:20px}
			.modal-header h2{margin:0; font-size:26px}
			.modal-close{background:rgba(255,255,255,.10); border:1px solid rgba(255,255,255,.20); color:#fff; width:32px; height:32px; border-radius:8px; cursor:pointer; font-size:20px; display:grid; place-items:center; transition:.2s}
			.modal-close:hover{background:rgba(255,255,255,.18)}
			.modal-body{color:#d4ddff; line-height:1.7}
			.modal-body h3{margin:24px 0 16px; color:#fff; font-size:20px; display:flex; align-items:center; gap:10px}
			.modal-body h3::before{content:''; width:4px; height:24px; background:linear-gradient(180deg, #af40ff, #5b42f3); border-radius:2px}
			
			/* Flow diagram */
			.flow-container{background:rgba(0,0,0,.2); border:1px solid rgba(255,255,255,.1); border-radius:12px; padding:24px; margin:20px 0}
			.flow-step{display:flex; align-items:center; gap:16px; margin:16px 0}
			.flow-step-box{background:linear-gradient(135deg, rgba(91,124,255,.15), rgba(47,58,166,.15)); border:2px solid rgba(91,124,255,.4); border-radius:12px; padding:16px 20px; flex:1; position:relative}
			.flow-step-box strong{display:block; color:#fff; font-size:16px; margin-bottom:6px}
			.flow-step-box p{margin:0; font-size:14px; color:#b9d4ff; line-height:1.5}
			.flow-step-number{width:36px; height:36px; border-radius:50%; background:linear-gradient(135deg, #af40ff, #5b42f3); display:grid; place-items:center; font-weight:700; font-size:16px; box-shadow:0 4px 12px rgba(91,66,243,.4); flex-shrink:0}
			.flow-arrow{width:100%; text-align:center; margin:8px 0; color:#8b9fff; font-size:24px}
			
			/* Process boxes */
			.process-grid{display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:12px; margin:16px 0}
			.process-box{background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:14px; text-align:center}
			.process-box-icon{width:48px; height:48px; margin:0 auto 10px; border-radius:10px; background:linear-gradient(135deg, #4158d0, #5b7cff); display:grid; place-items:center; font-size:24px}
			.process-box strong{display:block; color:#fff; margin-bottom:6px; font-size:15px}
			.process-box span{font-size:13px; color:#b9c3ff}
			
			/* Key concepts */
			.concept-card{background:linear-gradient(135deg, rgba(175,64,255,.08), rgba(91,66,243,.08)); border-left:3px solid #af40ff; border-radius:8px; padding:16px; margin:12px 0}
			.concept-card strong{color:#fff; font-size:16px; display:block; margin-bottom:8px}
			.concept-card p{margin:0; color:#d4ddff; line-height:1.6}
			
			.tip-box{background:rgba(0,221,235,.08); border:1px solid rgba(0,221,235,.3); border-radius:10px; padding:16px; margin:16px 0}
			.tip-box strong{color:#00ddeb; display:block; margin-bottom:8px; font-size:16px}
			.tip-box ul{margin:8px 0; padding-left:20px; color:#d4ddff}
			.tip-box li{margin-bottom:6px}
			
			.kbd{font-family:ui-monospace, 'Cascadia Code', 'Courier New', monospace; background:#0e1440; padding:3px 8px; border-radius:6px; border:1px solid rgba(255,255,255,.15); font-size:13px}
			.hero{display:grid}
			
			/* Text Mode Enhanced Styles */
			.section-header{display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:24px; gap:16px; flex-wrap:wrap}
			.section-header h2{margin:0; font-size:28px}
			.section-desc{color:#b9c3ff; margin:6px 0 0; font-size:15px; line-height:1.5}
			.encode-grid{display:grid; gap:20px}
			
			.input-section{background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.10); border-radius:12px; padding:18px}
			.input-header{display:flex; justify-content:space-between; align-items:center; margin-bottom:8px}
			.input-header label{margin:0; font-size:16px; font-weight:600}
			.char-counter{font-size:13px; color:#8b9fff; font-weight:500}
			.input-info{margin-top:8px}
			.info-badge{display:inline-flex; align-items:center; gap:6px; padding:6px 12px; background:rgba(175,64,255,.12); border:1px solid rgba(175,64,255,.25); border-radius:8px; font-size:13px; color:#d4b3ff}
			
			.mapping-section{margin:20px 0}
			.section-label{display:flex; justify-content:space-between; align-items:center; margin-bottom:14px; font-weight:600; font-size:16px}
			.reset-btn{background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.15); color:#fff; padding:6px 12px; border-radius:6px; cursor:pointer; font-size:14px; transition:.2s; font-weight:500}
			.reset-btn:hover{background:rgba(255,255,255,.15)}
			.mapping-grid{display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:14px}
			.map-item-enhanced{background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.15); border-radius:10px; padding:20px 16px; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:14px; transition:.2s; text-align:center; min-height:140px}
			.map-item-enhanced:hover{background:rgba(0,0,0,.35); border-color:rgba(255,255,255,.25)}
			.map-item-enhanced .map-header{display:flex; align-items:center; gap:12px}
			.map-item-enhanced .base{width:52px; height:52px; font-size:22px; flex-shrink:0}
			.map-item-enhanced input{width:100%; max-width:120px; margin:0; font-family:ui-monospace, monospace; font-size:20px; font-weight:700; text-align:center; letter-spacing:4px; padding:12px; background:rgba(0,0,0,.3); border:1px solid rgba(255,255,255,.2)}
			.map-item-enhanced input:focus{border-color:rgba(91,124,255,.5); outline:none; box-shadow:0 0 0 2px rgba(91,124,255,.15)}
			.map-label{font-size:14px; color:#b9c3ff; font-weight:600; text-transform:uppercase; letter-spacing:.5px}
			
			.action-row{display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content:center}
			
			.viz-section{background:linear-gradient(135deg, rgba(91,124,255,.06), rgba(47,58,166,.06)); border:1px solid rgba(91,124,255,.2); border-radius:12px; padding:20px}
			.viz-header{display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; flex-wrap:wrap; gap:10px}
			.viz-header label{margin:0; font-size:16px; font-weight:600}
			.viz-controls{display:flex; gap:12px; align-items:center}
			.base-count{font-size:14px; color:#a8c0ff; font-weight:500; padding:4px 10px; background:rgba(255,255,255,.06); border-radius:6px; border:1px solid rgba(255,255,255,.10)}
			.copy-btn{background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.18); color:#fff; padding:6px 12px; border-radius:6px; cursor:pointer; font-size:13px; transition:.2s; font-weight:500}
			.copy-btn:hover{background:rgba(255,255,255,.15); transform:translateY(-1px)}
			.copy-btn:active{transform:scale(0.95)}
			.dna-sequence-display{margin-top:16px; background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.12); border-radius:8px; padding:12px}
			.sequence-label{font-size:12px; color:#8b9fff; font-weight:600; margin-bottom:6px; text-transform:uppercase; letter-spacing:.5px}
			.sequence-text{font-family:ui-monospace, 'Cascadia Code', monospace; color:#fff; font-size:15px; line-height:1.8; word-break:break-all; letter-spacing:1px}
			
			.output-section{background:linear-gradient(135deg, rgba(0,221,235,.08), rgba(91,66,243,.08)); border:1px solid rgba(0,221,235,.25); border-radius:12px; padding:20px}
			.output-header{display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; flex-wrap:wrap; gap:10px}
			.output-header label{margin:0; font-size:16px; font-weight:600}
			.decoded-output{background:rgba(0,0,0,.3); border:1px solid rgba(255,255,255,.15); border-radius:8px; padding:14px; min-height:60px; color:#fff; font-size:16px; line-height:1.7; font-family:ui-monospace, 'Cascadia Code', monospace}
			.output-match{margin-top:10px; padding:8px 12px; border-radius:6px; font-size:14px; font-weight:500}
			.output-match.success{background:rgba(34,197,94,.15); border:1px solid rgba(34,197,94,.3); color:#86efac}
			.output-match.warning{background:rgba(251,191,36,.15); border:1px solid rgba(251,191,36,.3); color:#fde047}
			
			.helix{
			position:absolute; inset:0; margin:auto; width:100%; height:100%; transform-style:preserve-3d; animation: spin 18s linear infinite;
		}
		.rung{position:absolute; left:50%; top:50%; transform-style:preserve-3d}
		.rung .bead{width:16px; height:16px; border-radius:50%; position:absolute; top:-8px; box-shadow:0 2px 6px rgba(0,0,0,.5)}
		.rung .bond{position:absolute; top:-1px; left:0; height:2px; background:rgba(255,255,255,.5)}
		.bead.A{background:var(--red)} .bead.T{background:var(--blue)} .bead.C{background:var(--green)} .bead.G{background:var(--yellow)}
		@keyframes spin{ from{ transform: rotateY(0deg);} to{ transform: rotateY(360deg);} }

			/* Diagonal background helix */
				.bg-helix{position:fixed; inset:0; pointer-events:none; z-index:0; overflow:hidden}
					.bio-canvas{position:absolute; inset:0; width:100%; height:100%;}
					.bg-helix-wrap{position:absolute; width:1550px; height:1200px; left:50%; top:50%; transform-origin:center;
					transform: translate(-50%, -50%) rotateZ(-25deg) rotateX(20deg);}
				.bg-helix .helix{position:absolute; inset:0; width:100%; height:100%; opacity:.28; filter: drop-shadow(0 12px 24px rgba(0,0,0,.45));}

		/* Processing overlay */
		.overlay{position:fixed; inset:0; background:rgba(5,8,20,.72); display:grid; place-items:center; z-index:50}
		.spinner{display:grid; gap:14px; place-items:center}
		.dna-spinner{position:relative; width:180px; height:120px}
		.dna-dot{position:absolute; width:10px; height:10px; border-radius:50%; background:#8ab4ff; animation: wave 1.2s ease-in-out infinite}
		.dna-dot:nth-child(odd){background:#ff8aa6}
		@keyframes wave{ 0%,100%{ transform: translateY(0);} 50%{ transform: translateY(22px);} }
		.overlay p{color:#cfe1ff}

		.error{color:#ff9aa2; min-height:20px; margin-top:8px; text-align:center}
		.code{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:#0e1440; padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,.12)}
	</style>
</head>
<body>
	<div class="container">
		<!-- Intro View -->
			<!-- Background diagonal helix -->
				<div class="bg-helix">
						<canvas id="bioBackdrop" class="bio-canvas"></canvas>
					<div class="bg-helix-wrap">
						<div class="helix" id="bgHelix"></div>
					</div>
				</div>

			<section id="introView" class="card intro intro-fill">
				<div class="intro-content">
					<div class="hero-title">
						<div class="dna-logo">
							<svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
								<path d="M32 8c-4 0-7 3-7 7v34c0 4 3 7 7 7s7-3 7-7V15c0-4-3-7-7-7z" fill="url(#grad1)" opacity=".3"/>
								<circle cx="20" cy="16" r="4" fill="#d93025"/>
								<circle cx="44" cy="16" r="4" fill="#1a73e8"/>
								<line x1="20" y1="16" x2="44" y2="16" stroke="#fff" stroke-width="2" opacity=".5"/>
								<circle cx="18" cy="28" r="4" fill="#1e8e3e"/>
								<circle cx="46" cy="28" r="4" fill="#f9ab00"/>
								<line x1="18" y1="28" x2="46" y2="28" stroke="#fff" stroke-width="2" opacity=".5"/>
								<circle cx="20" cy="40" r="4" fill="#1a73e8"/>
								<circle cx="44" cy="40" r="4" fill="#d93025"/>
								<line x1="20" y1="40" x2="44" y2="40" stroke="#fff" stroke-width="2" opacity=".5"/>
								<circle cx="18" cy="52" r="4" fill="#f9ab00"/>
								<circle cx="46" cy="52" r="4" fill="#1e8e3e"/>
								<line x1="18" y1="52" x2="46" y2="52" stroke="#fff" stroke-width="2" opacity=".5"/>
								<defs>
									<linearGradient id="grad1" x1="0%" y1="0%" x2="0%" y2="100%">
										<stop offset="0%" style="stop-color:#5b7cff;stop-opacity:1" />
										<stop offset="100%" style="stop-color:#2e4ae8;stop-opacity:1" />
									</linearGradient>
								</defs>
							</svg>
						</div>
						<h1>DNA-Based Storage System</h1>
					</div>
					<p class="muted lead">Encode and decode data using DNA bases (A, T, C, G). Choose Text or Image mode, assign custom 2‑bit mappings, visualize sequences, and learn how DNA can serve as a dense storage medium.</p>
					
					<!-- Color legend -->
					<div class="pill-row">
						<span class="pill"><span class="dot A"></span> Adenine</span>
						<span class="pill"><span class="dot T"></span> Thymine</span>
						<span class="pill"><span class="dot C"></span> Cytosine</span>
						<span class="pill"><span class="dot G" style="border:1px solid rgba(0,0,0,.2)"></span> Guanine</span>
					</div>

					<!-- Feature grid -->
					<div class="feature-grid">
						<div class="feature">
							<div class="feature-icon">
								<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
									<path d="M12 2L2 7l10 5 10-5-10-5z" fill="#fff" opacity=".3"/>
									<path d="M2 17l10 5 10-5M2 12l10 5 10-5" stroke="#fff" stroke-width="2" stroke-linecap="round"/>
								</svg>
							</div>
							<h3>Custom Mappings</h3>
							<p>Assign any unique 2-bit codes (00, 01, 10, 11) to A, T, C, G and see real-time changes.</p>
						</div>
						<div class="feature">
							<div class="feature-icon">
								<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
									<rect x="3" y="3" width="18" height="18" rx="2" stroke="#fff" stroke-width="2"/>
									<circle cx="12" cy="12" r="4" fill="#fff"/>
								</svg>
							</div>
							<h3>Interactive Visualization</h3>
							<p>Double-strand canvas shows base pairs with hydrogen bonds (A–T: 2 bonds, C–G: 3 bonds).</p>
						</div>
						<div class="feature">
							<div class="feature-icon">
								<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
									<circle cx="8" cy="6" r="3" fill="#d93025"/>
									<circle cx="16" cy="6" r="3" fill="#1a73e8"/>
									<line x1="8" y1="6" x2="16" y2="6" stroke="#fff" stroke-width="1.5"/>
									<circle cx="7" cy="12" r="3" fill="#1e8e3e"/>
									<circle cx="17" cy="12" r="3" fill="#f9ab00"/>
									<line x1="7" y1="12" x2="17" y2="12" stroke="#fff" stroke-width="1.5"/>
									<circle cx="8" cy="18" r="3" fill="#1a73e8"/>
									<circle cx="16" cy="18" r="3" fill="#d93025"/>
									<line x1="8" y1="18" x2="16" y2="18" stroke="#fff" stroke-width="1.5"/>
								</svg>
							</div>
							<h3>Base-Pair Bonding</h3>
							<p>Visualize complementary pairing: A↔T and C↔G with accurate hydrogen bond representation.</p>
						</div>
						<div class="feature">
							<div class="feature-icon">
								<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
									<path d="M3 3h7v7H3zM14 3h7v7h-7zM3 14h7v7H3z" fill="#fff" opacity=".4"/>
									<path d="M14 14h3v3h-3zM18 14h3v3h-3zM14 18h3v3h-3zM18 18h3v3h-3z" fill="#fff"/>
								</svg>
							</div>
							<h3>Binary Encoding</h3>
							<p>Converts text and images to binary, then maps 2-bit chunks to DNA bases automatically.</p>
						</div>
					</div>

					<!-- Stats -->
					<div class="stats-row">
						<div class="stat-card"><strong>2 bits/base</strong><span>Each DNA base encodes a binary pair</span></div>
						<div class="stat-card"><strong>4 bases</strong><span>Adenine, Thymine, Cytosine, Guanine</span></div>
						<div class="stat-card"><strong>Reversible</strong><span>Lossless encode and decode process</span></div>
					</div>

					<div class="divider"></div>

					<div class="btns">
						<button id="goText" class="primary"><span>Go to Text Mode</span></button>
						<button id="goImage" class="secondary"><span>Go to Image Mode</span></button>
						<button id="showGuide" class="ghost"><span>How It Works</span></button>
					</div>
				</div>
			</section>

			<!-- How It Works Modal -->
			<div id="guideModal" class="modal hidden">
				<div class="modal-content">
					<div class="modal-header">
						<h2>How It Works</h2>
						<button class="modal-close" id="closeGuide">×</button>
					</div>
					<div class="modal-body">
						<p style="font-size:16px; margin-bottom:24px">This tool simulates DNA-based data storage by converting digital information into biological sequences.</p>
						
						<h3>🧬 Encoding Process</h3>
						<div class="flow-container">
							<div class="flow-step">
								<div class="flow-step-number">1</div>
								<div class="flow-step-box">
									<strong>Input Data</strong>
									<p>Enter text (e.g., "Hello") or upload an image file</p>
								</div>
							</div>
							<div class="flow-arrow">↓</div>
							<div class="flow-step">
								<div class="flow-step-number">2</div>
								<div class="flow-step-box">
									<strong>Convert to Binary</strong>
									<p>Text: ASCII → 8-bit binary | Image: Pixels → Grayscale → 8-bit binary</p>
								</div>
							</div>
							<div class="flow-arrow">↓</div>
							<div class="flow-step">
								<div class="flow-step-number">3</div>
								<div class="flow-step-box">
									<strong>Group into 2-bit Pairs</strong>
									<p>Binary split into chunks: 00, 01, 10, 11</p>
								</div>
							</div>
							<div class="flow-arrow">↓</div>
							<div class="flow-step">
								<div class="flow-step-number">4</div>
								<div class="flow-step-box">
									<strong>Map to DNA Bases</strong>
									<p>Each 2-bit pair → A, T, C, or G using your custom mapping</p>
								</div>
							</div>
							<div class="flow-arrow">↓</div>
							<div class="flow-step">
								<div class="flow-step-number">5</div>
								<div class="flow-step-box">
									<strong>Visualize Result</strong>
									<p>Double-strand display with complementary bases and hydrogen bonds</p>
								</div>
							</div>
						</div>

						<h3>🔄 Decoding Process</h3>
						<div class="process-grid">
							<div class="process-box">
								<div class="process-box-icon">🧬</div>
								<strong>DNA Input</strong>
								<span>Encoded sequence</span>
							</div>
							<div class="process-box">
								<div class="process-box-icon">→</div>
								<strong>Map to Bits</strong>
								<span>Bases → 2-bit pairs</span>
							</div>
							<div class="process-box">
								<div class="process-box-icon">01</div>
								<strong>Combine Binary</strong>
								<span>Pairs → 8-bit bytes</span>
							</div>
							<div class="process-box">
								<div class="process-box-icon">📄</div>
								<strong>Convert Back</strong>
								<span>Binary → Text/Image</span>
							</div>
						</div>

						<h3>🔑 Key Concepts</h3>
						
						<div class="concept-card">
							<strong>Base Pairing Rules</strong>
							<p><span class="kbd">A</span> pairs with <span class="kbd">T</span> (2 hydrogen bonds) • <span class="kbd">C</span> pairs with <span class="kbd">G</span> (3 hydrogen bonds)</p>
						</div>

						<div class="concept-card">
							<strong>Custom Mappings</strong>
							<p>You control which 2-bit code maps to which base. Must use all four unique codes: <span class="kbd">00</span> <span class="kbd">01</span> <span class="kbd">10</span> <span class="kbd">11</span></p>
						</div>

						<div class="concept-card">
							<strong>Lossless Storage</strong>
							<p>The encoding is completely reversible—decode will perfectly recover your original input using the same mapping.</p>
						</div>

						<div class="tip-box">
							<strong>💡 Quick Start Tips</strong>
							<ul>
								<li><strong>Text Mode:</strong> Type a message → Click "Encode to DNA" → View visualization → Click "Decode to text"</li>
								<li><strong>Image Mode:</strong> Upload image → Load Preview → Encode to see DNA sequence</li>
								<li><strong>Experiment:</strong> Try different mappings to see how the DNA sequence changes!</li>
								<li><strong>Visual Feedback:</strong> Colored bases show A (red), T (blue), C (green), G (yellow)</li>
							</ul>
						</div>
					</div>
				</div>
			</div>

		<!-- Text Mode View -->
		<section id="textView" class="card hidden" aria-labelledby="textTitle">
			<div class="section-header">
				<div>
					<h2 id="textTitle">Text Encoding / Decoding</h2>
					<p class="section-desc">Enter your message and convert it to DNA sequences using custom base mappings</p>
				</div>
				<button id="t_back" class="ghost"><span>← Back to Intro</span></button>
			</div>

			<div class="encode-grid">
				<!-- Input Section -->
				<div class="input-section">
					<div class="input-header">
						<label for="txtInput">📝 Input Text</label>
						<span class="char-counter" id="t_charCount">0 characters</span>
					</div>
					<textarea id="txtInput" placeholder="Type your message here...">Hello DNA!</textarea>
					<div class="input-info">
						<span class="info-badge">💡 Tip: Try short messages for clearer visualization</span>
					</div>
				</div>

				<!-- Mapping Section -->
				<div class="mapping-section">
					<div class="section-label">
						<span>🧬 Base-to-Binary Mapping</span>
						<button id="t_resetMap" class="reset-btn" title="Reset to default">↻ Reset</button>
					</div>
					<div class="mapping-grid">
						<div class="map-item-enhanced">
							<div class="map-header">
								<span class="base A">A</span>
								<span class="map-label">Adenine</span>
							</div>
							<input id="t_mapA" type="text" value="00" maxlength="2" pattern="[01]{2}" />
						</div>
						<div class="map-item-enhanced">
							<div class="map-header">
								<span class="base C">C</span>
								<span class="map-label">Cytosine</span>
							</div>
							<input id="t_mapC" type="text" value="01" maxlength="2" pattern="[01]{2}" />
						</div>
						<div class="map-item-enhanced">
							<div class="map-header">
								<span class="base G">G</span>
								<span class="map-label">Guanine</span>
							</div>
							<input id="t_mapG" type="text" value="10" maxlength="2" pattern="[01]{2}" />
						</div>
						<div class="map-item-enhanced">
							<div class="map-header">
								<span class="base T">T</span>
								<span class="map-label">Thymine</span>
							</div>
							<input id="t_mapT" type="text" value="11" maxlength="2" pattern="[01]{2}" />
						</div>
					</div>
				</div>

				<!-- Action Buttons -->
				<div class="action-row">
					<button id="btnEncodeText" class="primary"><span>🧬 Encode to DNA</span></button>
					<button id="btnDecodeText" class="secondary" disabled><span>🔄 Decode to Text</span></button>
				</div>
				<div id="t_error" class="error"></div>

				<!-- DNA Visualization -->
				<div class="viz-section" id="t_vizSection" style="display:none">
					<div class="viz-header">
						<label>🔬 DNA Double Helix Visualization</label>
						<div class="viz-controls">
							<span class="base-count" id="t_baseCount">0 base pairs</span>
							<button id="t_copyDNA" class="copy-btn" title="Copy DNA sequence">📋 Copy</button>
						</div>
					</div>
					<div class="viz-wrap">
						<canvas id="pairCanvas" height="180"></canvas>
					</div>
					<div class="legend">
						<span class="chip"><span class="dot" style="background:var(--red)"></span>A-T (2 bonds)</span>
						<span class="chip"><span class="dot" style="background:var(--blue)"></span>T-A (2 bonds)</span>
						<span class="chip"><span class="dot" style="background:var(--green)"></span>C-G (3 bonds)</span>
						<span class="chip"><span class="dot" style="background:var(--yellow); border:1px solid rgba(0,0,0,.2)"></span>G-C (3 bonds)</span>
					</div>
					<div class="dna-sequence-display">
						<div class="sequence-label">DNA Sequence:</div>
						<div class="sequence-text" id="t_dnaSeq"></div>
					</div>
				</div>

				<!-- Decoded Output -->
				<div class="output-section" id="t_outputSection" style="display:none">
					<div class="output-header">
						<label>✅ Decoded Output</label>
						<button id="t_copyDecoded" class="copy-btn" title="Copy decoded text">📋 Copy</button>
					</div>
					<div id="t_decoded" class="decoded-output"></div>
					<div class="output-match" id="t_matchStatus"></div>
				</div>
			</div>
		</section>

	<!-- Image Mode View -->
	<section id="imageView" class="card hidden" aria-labelledby="imgTitle">
		<div class="section-header">
			<div>
				<h2 id="imgTitle">Image Encoding / Decoding</h2>
				<p class="section-desc">Upload an image and convert it to DNA sequences using custom base mappings</p>
			</div>
			<button id="i_back" class="ghost"><span>← Back to Intro</span></button>
		</div>

		<div class="encode-grid">
			<!-- Mode Toggle -->
			<div style="display:flex; gap:10px; justify-content:center; margin-bottom:8px">
				<button id="i_uploadMode" class="secondary" style="min-width:auto; padding:3px"><span style="padding:10px 20px">📁 Upload Image</span></button>
				<button id="i_decodeMode" class="ghost" style="min-width:auto; padding:3px"><span style="padding:10px 20px">🧬 Decode DNA</span></button>
			</div>

		<!-- Upload Section -->
		<div class="input-section" id="i_uploadSection">
			<div class="input-header">
				<label for="imgFile">🖼️ Upload Image</label>
				<span class="char-counter" id="i_fileInfo">No file selected</span>
			</div>
			<div style="display:flex; gap:12px; align-items:center; flex-wrap:wrap">
				<input id="imgFile" type="file" accept="image/*" style="display:none" />
				<button id="i_chooseFile" class="ghost" style="min-width:auto; padding:3px; flex:1"><span style="padding:12px 20px">📁 Choose Image File</span></button>
				<button id="btnLoadImg" class="secondary" style="min-width:auto; padding:3px"><span style="padding:12px 20px">�️ Load Preview</span></button>
			</div>
			<div class="input-info">
				<span class="info-badge">💡 Tip: Smaller images work better for clear visualization</span>
			</div>
		</div>			<!-- Mapping Section -->
			<div class="mapping-section">
				<div class="section-label">
					<span>🧬 Base-to-Binary Mapping</span>
					<button id="i_resetMap" class="reset-btn" title="Reset to default">↻ Reset</button>
				</div>
				<div class="mapping-grid">
					<div class="map-item-enhanced">
						<div class="map-header">
							<span class="base A">A</span>
							<span class="map-label">Adenine</span>
						</div>
						<input id="i_mapA" type="text" value="00" maxlength="2" pattern="[01]{2}" />
					</div>
					<div class="map-item-enhanced">
						<div class="map-header">
							<span class="base C">C</span>
							<span class="map-label">Cytosine</span>
						</div>
						<input id="i_mapC" type="text" value="01" maxlength="2" pattern="[01]{2}" />
					</div>
					<div class="map-item-enhanced">
						<div class="map-header">
							<span class="base G">G</span>
							<span class="map-label">Guanine</span>
						</div>
						<input id="i_mapG" type="text" value="10" maxlength="2" pattern="[01]{2}" />
					</div>
					<div class="map-item-enhanced">
						<div class="map-header">
							<span class="base T">T</span>
							<span class="map-label">Thymine</span>
						</div>
						<input id="i_mapT" type="text" value="11" maxlength="2" pattern="[01]{2}" />
					</div>
				</div>
			</div>

		<!-- Preview Section -->
		<div class="viz-section" id="i_previewSection" style="display:none">
			<div class="viz-header">
				<label>📸 Image Preview</label>
				<span class="base-count" id="i_imgDimensions">0 x 0</span>
			</div>
			<div class="viz-wrap" style="text-align:center">
				<canvas id="imgPreview" width="256" height="256" style="background:#0a0f24; border-radius:8px; cursor:pointer; transition:transform 0.2s" 
					onmouseover="this.style.transform='scale(1.02)'" 
					onmouseout="this.style.transform='scale(1)'"
					title="Click to zoom"></canvas>
			</div>
		</div>			<!-- Action Buttons -->
			<div class="action-row">
				<button id="btnEncodeImg" class="primary" disabled><span>🧬 Encode to DNA</span></button>
				<button id="btnDecodeImg" class="secondary" disabled><span>🔄 Decode to Image</span></button>
			</div>
			<div id="i_error" class="error"></div>

		<!-- DNA Input/Output Section -->
		<div class="output-section" id="i_dnaSection" style="display:none">
			<div class="output-header">
				<label>🧬 DNA Sequence</label>
				<div class="viz-controls">
					<span class="base-count" id="i_baseCount">0 bases</span>
					<button id="i_copyDNA" class="copy-btn" title="Copy DNA sequence">📋 Copy</button>
				</div>
			</div>
			<div class="dna-sequence-display">
				<div class="sequence-label">DNA Sequence:</div>
				<div class="sequence-text" id="i_dnaOut" style="max-height:200px; overflow-y:auto"></div>
			</div>
		</div>

		<!-- DNA Input for Direct Decode -->
		<div class="input-section" id="i_directDecodeSection" style="display:none">
			<div class="input-header">
				<label for="i_dnaInput">🧬 Enter DNA Sequence to Decode</label>
				<span class="char-counter" id="i_dnaCharCount">0 bases</span>
			</div>
			<textarea id="i_dnaInput" placeholder="Paste DNA sequence here (ATCG only)..." style="min-height:120px; font-family:monospace; letter-spacing:1px"></textarea>
			<div class="input-info">
				<span class="info-badge">💡 Tip: Image dimensions are automatically detected from the DNA sequence</span>
			</div>
			<div class="action-row" style="margin-top:16px">
				<button id="btnDecodeFromDNA" class="primary" disabled><span>🔄 Decode DNA to Image</span></button>
			</div>
		</div>			<!-- Decoded Image Section -->
			<div class="viz-section" id="i_decodedSection" style="display:none">
				<div class="viz-header">
					<label>✅ Decoded Image</label>
					<button id="i_downloadImg" class="copy-btn" title="Download decoded image">💾 Download</button>
				</div>
				<div class="viz-wrap" style="text-align:center">
					<canvas id="imgDecoded" width="256" height="256" style="background:#0a0f24; border-radius:8px; cursor:pointer; transition:transform 0.2s"
					onmouseover="this.style.transform='scale(1.02)'" 
					onmouseout="this.style.transform='scale(1)'"
					title="Click to zoom"></canvas>
				</div>
				<div class="output-match success" style="margin-top:12px">
					✓ Image successfully decoded from DNA sequence
				</div>
			</div>
		</div>
	</section>
		</section>
	</div>

	<!-- Image Zoom Modal -->
	<div id="imageZoomModal" class="modal hidden" style="background:rgba(5,8,20,.92)">
		<div style="position:relative; max-width:90vw; max-height:90vh; display:flex; align-items:center; justify-content:center">
			<button id="closeZoom" class="modal-close" style="position:absolute; top:-40px; right:0">×</button>
			<canvas id="zoomedImage" style="border-radius:12px; box-shadow:0 20px 60px rgba(0,0,0,.8); image-rendering: pixelated; image-rendering: crisp-edges"></canvas>
		</div>
	</div>

	<!-- Processing Overlay -->
	<div id="processing" class="overlay hidden" role="alert" aria-live="polite">
		<div class="spinner">
			<div class="dna-spinner" id="spinnerDNA"></div>
			<p id="processingText">Processing…</p>
		</div>
	</div>

	<script>
		// Basic colors and complements
		const COLORS = { A: '#d93025', C: '#1e8e3e', G: '#f9ab00', T: '#1a73e8' };
		const COMPLEMENT = { A: 'T', T: 'A', C: 'G', G: 'C' };

		// View elements
		const introView = document.getElementById('introView');
		const textView = document.getElementById('textView');
		const imageView = document.getElementById('imageView');

		const goText = document.getElementById('goText');
		const goImage = document.getElementById('goImage');
		const showGuide = document.getElementById('showGuide');
		const guideModal = document.getElementById('guideModal');
		const closeGuide = document.getElementById('closeGuide');
		const tBack = document.getElementById('t_back');
		const iBack = document.getElementById('i_back');

		// Processing overlay
		const processing = document.getElementById('processing');
		const processingText = document.getElementById('processingText');

		function showView(view){
			for(const v of [introView, textView, imageView]) v.classList.add('hidden');
			view.classList.remove('hidden');
		}

		goText.addEventListener('click', ()=> showView(textView));
		goImage.addEventListener('click', ()=> showView(imageView));
		showGuide.addEventListener('click', ()=> guideModal.classList.remove('hidden'));
		closeGuide.addEventListener('click', ()=> guideModal.classList.add('hidden'));
		guideModal.addEventListener('click', (e)=> { if(e.target === guideModal) guideModal.classList.add('hidden'); });
		tBack.addEventListener('click', ()=> showView(introView));
		iBack.addEventListener('click', ()=> showView(introView));

		function showProcessing(msg='Processing…', ms=1200){
			processingText.textContent = msg;
			processing.classList.remove('hidden');
			return new Promise(resolve => setTimeout(()=>{ processing.classList.add('hidden'); resolve(); }, ms));
		}

		// Build intro helix and spinner DNA dots procedurally
		function buildHelix(el, rungs=28, radius=140, gap=18){
			el.innerHTML = '';
			for(let i=0;i<rungs;i++){
				const rung = document.createElement('div');
				rung.className = 'rung';
				const angle = i * (360 / rungs);
				const y = (i - rungs/2) * gap;
				rung.style.transform = `translate3d(-50%, -50%, 0) rotateY(${angle}deg) translateZ(${radius}px) translateY(${y}px)`;
				// two beads and a bond
				const left = document.createElement('div'); left.className='bead A'; left.style.left='-70px';
				const right = document.createElement('div'); right.className='bead T'; right.style.left='54px';
				const bond = document.createElement('div'); bond.className='bond'; bond.style.width='120px'; bond.style.left='-60px';
				rung.append(left, bond, right);
				el.appendChild(rung);
			}
		}

		function buildSpinnerDots(el){
			el.innerHTML = '';
			const w=180, h=120, cols=18; // wave of dots
			for(let i=0;i<cols;i++){
				const dot = document.createElement('div');
				dot.className = 'dna-dot';
				const x = 10 + i*10;
				const phase = (i%2)*0.15;
				dot.style.left = x+'px';
				dot.style.top = (h/2 - 5)+'px';
				dot.style.animationDelay = (phase)+'s';
				el.appendChild(dot);
			}
		}

			buildHelix(document.getElementById('bgHelix'), 64, 360, 26);

			// BIO BACKDROP (mini DNA and RNA strands only)
			const bioCanvas = document.getElementById('bioBackdrop');
			const bctx = bioCanvas.getContext('2d');
			const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
			let BW = 0, BH = 0;

			function resizeBio(){
				BW = window.innerWidth; BH = window.innerHeight;
				bioCanvas.width = Math.floor(BW * DPR);
				bioCanvas.height = Math.floor(BH * DPR);
				bioCanvas.style.width = BW + 'px';
				bioCanvas.style.height = BH + 'px';
				bctx.setTransform(DPR, 0, 0, DPR, 0, 0);
			}

			// Generate approximately uniform points across the screen using a jittered grid
			function gridPoints(count, marginX=40, marginY=40){
				const pts = [];
				const cols = Math.max(1, Math.ceil(Math.sqrt(count * (BW/BH))));
				const rows = Math.max(1, Math.ceil(count / cols));
				const innerW = Math.max(10, BW - marginX*2);
				const innerH = Math.max(10, BH - marginY*2);
				const cellW = innerW / cols;
				const cellH = innerH / rows;
				for(let i=0;i<count;i++){
					const r = Math.floor(i / cols);
					const c = i % cols;
					const jitterX = (Math.random() - 0.5) * cellW * 0.6; // +/-30% jitter
					const jitterY = (Math.random() - 0.5) * cellH * 0.6;
					const x = marginX + c*cellW + cellW/2 + jitterX;
					const y = marginY + r*cellH + cellH/2 + jitterY;
					pts.push({x,y});
				}
				return pts;
			}

			const dnaSprites = []; const rnaSprites = [];
			const particles = []; const vesicles = []; const filaments = []; const orbits = [];
			function initBio(){
				dnaSprites.length = 0; rnaSprites.length = 0; particles.length = 0; vesicles.length = 0; filaments.length = 0; orbits.length = 0;
				const dnaCount = Math.max(3, Math.floor((BW*BH)/360000));
				const rnaCount = Math.max(6, Math.floor((BW*BH)/220000));
				const dnaPts = gridPoints(dnaCount, 40, 40);
				for(let i=0;i<dnaCount;i++){
					const p = dnaPts[i];
					dnaSprites.push({
						x: p.x, y: p.y,
						vx: (Math.random()-.5)*0.06, vy:(Math.random()-.5)*0.06,
						scale: 0.7 + Math.random()*0.8,
						len: 8 + Math.floor(Math.random()*8),
						space: 14 + Math.random()*6,
						angle: Math.random()*Math.PI*2,
						wob: Math.random()*Math.PI*2
					});
				}
				const rnaPts = gridPoints(rnaCount, 60, 60);
				for(let i=0;i<rnaCount;i++){
					const p = rnaPts[i];
					rnaSprites.push({
						x: p.x, y: p.y,
						vx: (Math.random()-.5)*0.08, vy:(Math.random()-.5)*0.08,
						len: 120 + Math.random()*120,
						amp: 8 + Math.random()*10,
						freq: 0.02 + Math.random()*0.02,
						phase: Math.random()*Math.PI*2,
						beadStep: 16 + Math.random()*6,
						scale: 0.8 + Math.random()*1.2,
						angle: Math.random()*Math.PI*2
					});
				}

				// small floating particles
				const pCount = Math.max(24, Math.floor((BW+BH)/18));
				for(let i=0;i<pCount;i++){
					particles.push({ x: Math.random()*BW, y: Math.random()*BH, r: 1 + Math.random()*1.8, a: Math.random()*Math.PI*2, s: .15 + .45*Math.random() });
				}

				// vesicles (ring-like organelles)
				const vCount = Math.max(5, Math.floor((BW*BH)/420000));
				for(let i=0;i<vCount;i++){
					const r = 14 + Math.random()*22;
					vesicles.push({ x: Math.random()*BW, y: Math.random()*BH, r, rot: Math.random()*Math.PI*2, vr:(Math.random()-.5)*0.0015,
						vx:(Math.random()-.5)*0.08, vy:(Math.random()-.5)*0.08, alpha: 0.08 + Math.random()*0.06 });
				}

				// filaments (wavy microtubule-like lines)
				const fCount = Math.max(3, Math.floor((BW+BH)/900));
				for(let i=0;i<fCount;i++){
					filaments.push({ y0: Math.random()*BH, amp: 8+Math.random()*16, k: 0.003+Math.random()*0.006, phase: Math.random()*Math.PI*2, speed: 0.0015+Math.random()*0.003, w: 1+Math.random()*1.2, alpha: 0.10 });
				}

				// molecular orbits (tiny rings with dots)
				const oCount = Math.max(4, Math.floor((BW*BH)/950000));
				for(let i=0;i<oCount;i++){
					const cx = Math.random()*BW, cy = Math.random()*BH; const R = 18+Math.random()*30; const n = 3+Math.floor(Math.random()*3);
					const dots = Array.from({length:n}, (_,d)=>({ ang: Math.random()*Math.PI*2 + d*(Math.PI*2/n), speed: 0.006 + Math.random()*0.014, r:1.3+Math.random()*1.3 }));
					orbits.push({ cx, cy, R, dots });
				}
			}

			function drawMiniDNA(s){
				const amp = 8*s.scale; const rungW = 12*s.scale;
				bctx.save(); bctx.translate(s.x, s.y); bctx.rotate(s.angle);
				for(let k=0;k<s.len;k++){
					const y = (k - s.len/2)*s.space*s.scale;
					const off = Math.sin(s.wob + k*0.7)*amp;
					// bonds
					bctx.strokeStyle = 'rgba(255,255,255,0.30)'; bctx.lineWidth = 1;
					bctx.beginPath(); bctx.moveTo(-off - rungW/2, y); bctx.lineTo(off + rungW/2, y); bctx.stroke();
					// beads (two strands)
					bctx.fillStyle = '#ff8aa6'; bctx.beginPath(); bctx.arc(-off - rungW/2, y, 2.2*s.scale, 0, Math.PI*2); bctx.fill();
					bctx.fillStyle = '#8ab4ff'; bctx.beginPath(); bctx.arc(off + rungW/2, y, 2.2*s.scale, 0, Math.PI*2); bctx.fill();
				}
				bctx.restore();
			}

			function drawMiniRNA(s){
				bctx.save(); bctx.translate(s.x, s.y); bctx.rotate(s.angle);
				bctx.strokeStyle = 'rgba(200,220,255,0.25)'; bctx.lineWidth = 1.2;
				bctx.beginPath();
				for(let i=0;i<=s.len;i+=6){
					const x = (i - s.len/2) * s.scale;
					const y = Math.sin(s.freq*i + s.phase)*s.amp*s.scale;
					if(i===0) bctx.moveTo(x,y); else bctx.lineTo(x,y);
				}
				bctx.stroke();
				// beads every beadStep
				for(let i=0;i<=s.len;i+=s.beadStep){
					const x = (i - s.len/2) * s.scale;
					const y = Math.sin(s.freq*i + s.phase)*s.amp*s.scale;
					bctx.fillStyle = i%2? '#22d3ee' : '#a78bfa';
					bctx.beginPath(); bctx.arc(x,y,2*s.scale,0,Math.PI*2); bctx.fill();
				}
				bctx.restore();
			}

			function drawParticle(p){ bctx.fillStyle = 'rgba(200,220,255,0.20)'; bctx.beginPath(); bctx.arc(p.x, p.y, p.r, 0, Math.PI*2); bctx.fill(); }
			function drawVesicle(v){ const {x,y,r} = v; bctx.save(); bctx.translate(x,y); bctx.rotate(v.rot); bctx.strokeStyle = `rgba(160,200,255,${v.alpha})`; bctx.lineWidth = 2; bctx.beginPath(); bctx.ellipse(0,0,r, r*0.7, 0, 0, Math.PI*2); bctx.stroke(); bctx.globalAlpha = v.alpha*0.6; bctx.lineWidth=1; bctx.beginPath(); bctx.ellipse(0,0,r*0.6, r*0.42, 0, 0, Math.PI*2); bctx.stroke(); bctx.restore(); }
			function drawFilament(f){ const steps = 64; bctx.save(); bctx.strokeStyle = `rgba(160,190,255,${f.alpha})`; bctx.lineWidth = f.w; bctx.beginPath(); for(let i=0;i<=steps;i++){ const x = (i/steps)*BW; const y = f.y0 + Math.sin(f.k*x + f.phase)*f.amp; if(i===0) bctx.moveTo(x,y); else bctx.lineTo(x,y);} bctx.stroke(); bctx.restore(); }
			function drawOrbit(o){ bctx.save(); bctx.strokeStyle='rgba(150,180,255,0.10)'; bctx.lineWidth=1; bctx.beginPath(); bctx.arc(o.cx,o.cy,o.R,0,Math.PI*2); bctx.stroke(); for(const d of o.dots){ const x = o.cx + Math.cos(d.ang)*o.R; const y = o.cy + Math.sin(d.ang)*o.R; bctx.fillStyle = 'rgba(200,220,255,0.22)'; bctx.beginPath(); bctx.arc(x,y,d.r,0,Math.PI*2); bctx.fill(); } bctx.restore(); }

			let lastT=0; const parallax = {x:0,y:0, tx:0, ty:0};
			window.addEventListener('mousemove', (e)=>{ if(!BW||!BH) return; parallax.tx = (e.clientX/BW - .5)*18; parallax.ty = (e.clientY/BH - .5)*14; });
			function tick(t){
				if(!lastT) lastT=t; const dt = Math.min(33, t-lastT); lastT=t;
				bctx.clearRect(0,0,BW,BH);
				// vignette
				const vg = bctx.createRadialGradient(BW/2,BH/2,Math.min(BW,BH)/3, BW/2,BH/2, Math.max(BW,BH));
				vg.addColorStop(0,'rgba(0,0,0,0)'); vg.addColorStop(1,'rgba(0,0,0,0.12)');
				bctx.fillStyle = vg; bctx.fillRect(0,0,BW,BH);
				// parallax
				parallax.x += (parallax.tx - parallax.x)*0.05; parallax.y += (parallax.ty - parallax.y)*0.05; bctx.save(); bctx.translate(parallax.x, parallax.y);
				// filaments (behind)
				for(const f of filaments){ f.phase += f.speed*dt; drawFilament(f); }
				// vesicles
				for(const v of vesicles){ v.x += v.vx*dt; v.y += v.vy*dt; v.rot += v.vr*dt; if(v.x<-v.r) v.x=BW+v.r; if(v.x>BW+v.r) v.x=-v.r; if(v.y<-v.r) v.y=BH+v.r; if(v.y>BH+v.r) v.y=-v.r; drawVesicle(v); }
				// molecular orbits
				for(const o of orbits){ for(const d of o.dots){ d.ang += d.speed*dt; } drawOrbit(o); }
				// particles
				for(const p of particles){ p.x += Math.cos(p.a)*p.s; p.y += Math.sin(p.a)*p.s; p.a += 0.0025; if(p.x < -2) p.x = BW+2; if(p.x>BW+2) p.x=-2; if(p.y<-2) p.y=BH+2; if(p.y>BH+2) p.y=-2; drawParticle(p); }
				// update and draw DNA sprites
				for(const s of dnaSprites){ s.x += s.vx*dt; s.y += s.vy*dt; s.wob += 0.002*dt; s.angle += 0.0006*dt; if(s.x<-40) s.x=BW+40; if(s.x>BW+40) s.x=-40; if(s.y<-40) s.y=BH+40; if(s.y>BH+40) s.y=-40; drawMiniDNA(s); }
				// update and draw RNA sprites
				for(const s of rnaSprites){ s.x += s.vx*dt; s.y += s.vy*dt; s.phase += 0.004*dt; s.angle += 0.0004*dt; if(s.x<-60) s.x=BW+60; if(s.x>BW+60) s.x=-60; if(s.y<-60) s.y=BH+60; if(s.y>BH+60) s.y=-60; drawMiniRNA(s); }
				bctx.restore();
				requestAnimationFrame(tick);
			}

			// start backdrop
			resizeBio(); initBio(); requestAnimationFrame(tick);
			window.addEventListener('resize', ()=>{ resizeBio(); initBio(); });
		buildSpinnerDots(document.getElementById('spinnerDNA'));

		// TEXT MODE LOGIC
		const txtInput = document.getElementById('txtInput');
		const t_error = document.getElementById('t_error');
		const t_decoded = document.getElementById('t_decoded');
		const pairCanvas = document.getElementById('pairCanvas');
		const pctx = pairCanvas.getContext('2d');
		const btnEncodeText = document.getElementById('btnEncodeText');
		const btnDecodeText = document.getElementById('btnDecodeText');
		const t_charCount = document.getElementById('t_charCount');
		const t_baseCount = document.getElementById('t_baseCount');
		const t_dnaSeq = document.getElementById('t_dnaSeq');
		const t_vizSection = document.getElementById('t_vizSection');
		const t_outputSection = document.getElementById('t_outputSection');
		const t_matchStatus = document.getElementById('t_matchStatus');
		const t_copyDNA = document.getElementById('t_copyDNA');
		const t_copyDecoded = document.getElementById('t_copyDecoded');
		const t_resetMap = document.getElementById('t_resetMap');

		const tMap = {
			A: document.getElementById('t_mapA'),
			C: document.getElementById('t_mapC'),
			G: document.getElementById('t_mapG'),
			T: document.getElementById('t_mapT'),
		};

		let T_lastBits = '';
		let T_currentDNA = '';
		let T_originalText = '';

		// Check if input is a valid DNA sequence
		function isDNASequence(text) {
			const cleaned = text.replace(/\s/g, '').toUpperCase();
			return cleaned.length > 0 && /^[ATCG]+$/.test(cleaned);
		}

		// Update button states based on input
		function updateButtonStates() {
			const inputText = txtInput.value.trim();
			if (!inputText) {
				btnEncodeText.disabled = true;
				btnDecodeText.disabled = true;
				return;
			}

			const isDNA = isDNASequence(inputText);
			btnEncodeText.disabled = false;
			btnDecodeText.disabled = !isDNA;
		}

		// Character counter
		txtInput.addEventListener('input', ()=> {
			const len = txtInput.value.length;
			t_charCount.textContent = `${len} character${len !== 1 ? 's' : ''}`;
			updateButtonStates();
		});

		// Initialize button states
		updateButtonStates();

		// Reset mapping
		t_resetMap.addEventListener('click', ()=> {
			tMap.A.value = '00';
			tMap.C.value = '01';
			tMap.G.value = '10';
			tMap.T.value = '11';
		});

		// Copy functions
		t_copyDNA.addEventListener('click', async ()=> {
			if(T_currentDNA){
				await navigator.clipboard.writeText(T_currentDNA);
				t_copyDNA.textContent = '✓ Copied!';
				setTimeout(()=> t_copyDNA.textContent = '📋 Copy', 2000);
			}
		});

		t_copyDecoded.addEventListener('click', async ()=> {
			const text = t_decoded.textContent;
			if(text){
				await navigator.clipboard.writeText(text);
				t_copyDecoded.textContent = '✓ Copied!';
				setTimeout(()=> t_copyDecoded.textContent = '📋 Copy', 2000);
			}
		});

		function getMappingsText(){
			return { A: tMap.A.value.trim(), C: tMap.C.value.trim(), G: tMap.G.value.trim(), T: tMap.T.value.trim() };
		}
		function validateMappings(m){
			const vals = Object.values(m);
			for(const v of vals){ if(!/^[01]{2}$/.test(v)) return 'Each mapping must be two bits (00,01,10,11).'; }
			if(new Set(vals).size !== 4) return 'All four mappings must be unique.';
			return null;
		}
		function textToBinary(text){ return text.split('').map(ch=>{ const b=ch.charCodeAt(0).toString(2); return '0'.repeat(8-b.length)+b; }).join(''); }
		function binaryToText(bits){ let out=''; for(let i=0;i<bits.length;i+=8){ const byte=bits.substr(i,8); if(byte.length===8) out+=String.fromCharCode(parseInt(byte,2)); } return out; }
		function revMap(m){ return Object.fromEntries(Object.entries(m).map(([k,v])=>[v,k])); }
		function bitsToDNA(bits, m){ const R=revMap(m); let dna=''; for(let i=0;i<bits.length;i+=2){ const base=R[bits.substr(i,2)]; dna+=base||''; } return dna; }
		function dnaToBits(dna, m){ return dna.split('').map(b=>m[b]).join(''); }

		function drawPairs(dna){
			const blockW=24, blockH=26, midGap=20, pad=14, rowGap=12;
			const canvasWidth = pairCanvas.parentElement.clientWidth || 800;
			const maxPerRow = Math.min(40, Math.max(8, Math.floor((canvasWidth - 2*pad)/blockW)));
			const rows = Math.ceil((dna.length||1)/maxPerRow);
			const actualCols = Math.min(dna.length, maxPerRow);
			
			// Calculate total width needed and center if less than full width
			const contentWidth = actualCols * blockW;
			const totalWidth = Math.max(contentWidth + 2*pad, canvasWidth);
			const offsetX = (totalWidth - contentWidth) / 2;
			
			pairCanvas.width = totalWidth;
			pairCanvas.height = pad*2 + rows*(blockH*2 + midGap) + (rows-1)*rowGap;
			pctx.clearRect(0,0,pairCanvas.width,pairCanvas.height);
			pctx.textAlign='center'; pctx.textBaseline='middle'; pctx.font='bold 12px system-ui';

			for(let i=0;i<dna.length;i++){
				const row = Math.floor(i/maxPerRow);
				const col = i%maxPerRow;
				const x = offsetX + col*blockW;
				const yTop = pad + row*(blockH*2 + midGap + rowGap);
				const yBot = yTop + blockH + midGap;
				const b1 = dna[i];
				const b2 = COMPLEMENT[b1];
				// bonds: A–T 2 bonds, C–G 3 bonds
				const bonds = ( (b1==='A' && b2==='T') || (b1==='T' && b2==='A') ) ? 2 : 3;
				// draw blocks
				pctx.fillStyle = COLORS[b1]||'#888'; pctx.fillRect(x, yTop, blockW-3, blockH);
				pctx.fillStyle = COLORS[b2]||'#888'; pctx.fillRect(x, yBot, blockW-3, blockH);
				pctx.fillStyle = (b1==='G')? '#222':'#fff'; pctx.fillText(b1, x+(blockW-3)/2, yTop+blockH/2);
				pctx.fillStyle = (b2==='G')? '#222':'#fff'; pctx.fillText(b2, x+(blockW-3)/2, yBot+blockH/2);
				// bonds lines
				const bondSpacing = 6; const x0 = x+4; const x1=x+(blockW-7);
				const midY = yTop+blockH + midGap/2;
				pctx.strokeStyle = 'rgba(255,255,255,.6)'; pctx.lineWidth=1.5;
				pctx.beginPath();
				if(bonds===2){
					pctx.moveTo(x0, midY-bondSpacing); pctx.lineTo(x1, midY-bondSpacing);
					pctx.moveTo(x0, midY+bondSpacing); pctx.lineTo(x1, midY+bondSpacing);
				}else{
					pctx.moveTo(x0, midY-bondSpacing*1.2); pctx.lineTo(x1, midY-bondSpacing*1.2);
					pctx.moveTo(x0, midY); pctx.lineTo(x1, midY);
					pctx.moveTo(x0, midY+bondSpacing*1.2); pctx.lineTo(x1, midY+bondSpacing*1.2);
				}
				pctx.stroke();
			}
		}

		async function onEncodeText(){
			t_error.textContent=''; t_decoded.textContent=''; t_matchStatus.textContent='';
			t_outputSection.style.display = 'none';
			
			const m = getMappingsText(); const err = validateMappings(m); 
			if(err){ t_error.textContent=err; return; }
			if(!txtInput.value){ t_error.textContent='Please enter some text.'; return; }
			
			const inputText = txtInput.value.trim();
			const isDNA = isDNASequence(inputText);
			
			if(isDNA) {
				// Input is already DNA sequence, just visualize it
				await showProcessing('Visualizing DNA sequence…');
				T_currentDNA = inputText.replace(/\s/g, '').toUpperCase();
				T_originalText = ''; // No original text since input was DNA
			} else {
				// Normal text encoding
				await showProcessing('Encoding to DNA…');
				T_originalText = inputText;
				T_lastBits = textToBinary(T_originalText);
				T_currentDNA = bitsToDNA(T_lastBits, m);
			}
			
			// Show visualization
			drawPairs(T_currentDNA);
			t_vizSection.style.display = 'block';
			t_baseCount.textContent = `${T_currentDNA.length} base pair${T_currentDNA.length !== 1 ? 's' : ''}`;
			t_dnaSeq.textContent = T_currentDNA;
			
			// Update decode button state
			updateButtonStates();
		}
		
		async function onDecodeText(){
			t_error.textContent=''; t_matchStatus.textContent='';
			
			const m = getMappingsText(); const err = validateMappings(m); 
			if(err){ t_error.textContent=err; return; }
			
			const inputText = txtInput.value.trim();
			if(!inputText){ t_error.textContent='Please enter DNA sequence to decode.'; return; }
			
			// Get DNA sequence from input or from encoded sequence
			let dnaToDecod = '';
			if(isDNASequence(inputText)) {
				dnaToDecod = inputText.replace(/\s/g, '').toUpperCase();
			} else if(T_currentDNA) {
				dnaToDecod = T_currentDNA;
			} else {
				t_error.textContent='Please enter a valid DNA sequence or encode text first.';
				return;
			}
			
			await showProcessing('Decoding to text…');
			
			const bits = dnaToBits(dnaToDecod, m);
			const decodedText = binaryToText(bits);
			t_decoded.textContent = decodedText;
			
			// Show output section
			t_outputSection.style.display = 'block';
			
			// Check if matches original (only if we had original text)
			if(T_originalText && dnaToDecod === T_currentDNA) {
				if(decodedText === T_originalText){
					t_matchStatus.className = 'output-match success';
					t_matchStatus.textContent = '✓ Perfect match! Decoded text matches original input.';
				} else {
					t_matchStatus.className = 'output-match warning';
					t_matchStatus.textContent = '⚠ Decoded text differs from original (check mappings).';
				}
			} else {
				// DNA was entered directly
				t_matchStatus.className = 'output-match success';
				t_matchStatus.textContent = '✓ DNA sequence decoded successfully.';
			}
		}

		btnEncodeText.addEventListener('click', onEncodeText);
		btnDecodeText.addEventListener('click', onDecodeText);

	// IMAGE MODE LOGIC
	const imgFile = document.getElementById('imgFile');
	const i_chooseFile = document.getElementById('i_chooseFile');
	const btnLoadImg = document.getElementById('btnLoadImg');
	const btnEncodeImg = document.getElementById('btnEncodeImg');
	const btnDecodeImg = document.getElementById('btnDecodeImg');
	const imgPreview = document.getElementById('imgPreview');
	const imgDecoded = document.getElementById('imgDecoded');
	const iptx = imgPreview.getContext('2d');
	const idtx = imgDecoded.getContext('2d');
	const i_error = document.getElementById('i_error');
	const i_dnaOut = document.getElementById('i_dnaOut');
	const i_fileInfo = document.getElementById('i_fileInfo');
	const i_imgDimensions = document.getElementById('i_imgDimensions');
	const i_previewSection = document.getElementById('i_previewSection');
	const i_previewHeader = document.getElementById('i_previewHeader');
	const i_previewContent = document.getElementById('i_previewContent');
	const i_previewToggle = document.getElementById('i_previewToggle');
	const i_dnaSection = document.getElementById('i_dnaSection');
	const i_decodedSection = document.getElementById('i_decodedSection');
	const i_baseCount = document.getElementById('i_baseCount');
	const i_copyDNA = document.getElementById('i_copyDNA');
	const i_downloadImg = document.getElementById('i_downloadImg');
	const i_resetMap = document.getElementById('i_resetMap');
	const i_uploadMode = document.getElementById('i_uploadMode');
	const i_decodeMode = document.getElementById('i_decodeMode');
	const i_uploadSection = document.getElementById('i_uploadSection');
	const i_directDecodeSection = document.getElementById('i_directDecodeSection');
	const i_dnaInput = document.getElementById('i_dnaInput');
	const imageZoomModal = document.getElementById('imageZoomModal');
	const zoomedImage = document.getElementById('zoomedImage');
	const closeZoom = document.getElementById('closeZoom');
	const i_dnaCharCount = document.getElementById('i_dnaCharCount');
	const btnDecodeFromDNA = document.getElementById('btnDecodeFromDNA');
	const iMap = { A: document.getElementById('i_mapA'), C: document.getElementById('i_mapC'), G: document.getElementById('i_mapG'), T: document.getElementById('i_mapT') };

	let I_currentDNA = '';
	let I_imageWidth = 0;
	let I_imageHeight = 0;
	let I_imageBits = '';
	let I_currentMode = 'upload'; // 'upload' or 'decode'
	let I_previewExpanded = true;

	function getMappingsImage(){ return { A:iMap.A.value.trim(), C:iMap.C.value.trim(), G:iMap.G.value.trim(), T:iMap.T.value.trim() }; }

	// Choose file button
	i_chooseFile.addEventListener('click', ()=> {
		imgFile.click();
	});

	// Image zoom functionality
	function showZoomModal(sourceCanvas) {
		const zoomedCtx = zoomedImage.getContext('2d');
		// Calculate zoom scale (aim for 4x or fit within viewport)
		const zoomScale = 4;
		const maxWidth = window.innerWidth * 0.9;
		const maxHeight = window.innerHeight * 0.9;
		
		let targetWidth = sourceCanvas.width * zoomScale;
		let targetHeight = sourceCanvas.height * zoomScale;
		
		// Scale down if too large for viewport
		if(targetWidth > maxWidth || targetHeight > maxHeight) {
			const scale = Math.min(maxWidth / targetWidth, maxHeight / targetHeight);
			targetWidth *= scale;
			targetHeight *= scale;
		}
		
		// Set zoomed canvas dimensions
		zoomedImage.width = targetWidth;
		zoomedImage.height = targetHeight;
		
		// Disable image smoothing for crisp pixels
		zoomedCtx.imageSmoothingEnabled = false;
		
		// Copy and scale the source canvas to zoomed canvas
		zoomedCtx.drawImage(sourceCanvas, 0, 0, targetWidth, targetHeight);
		
		// Show modal by removing hidden class
		imageZoomModal.classList.remove('hidden');
	}

	imgPreview.addEventListener('click', ()=> {
		if(imgPreview.width > 0 && imgPreview.height > 0) {
			showZoomModal(imgPreview);
		}
	});

	imgDecoded.addEventListener('click', ()=> {
		if(imgDecoded.width > 0 && imgDecoded.height > 0) {
			showZoomModal(imgDecoded);
		}
	});

	closeZoom.addEventListener('click', ()=> {
		imageZoomModal.classList.add('hidden');
	});

	imageZoomModal.addEventListener('click', (e)=> {
		// Close when clicking the backdrop (not the canvas)
		if(e.target === imageZoomModal) {
			imageZoomModal.classList.add('hidden');
		}
	});

	// Mode switching
	i_uploadMode.addEventListener('click', ()=> {
		I_currentMode = 'upload';
		i_uploadMode.className = 'secondary';
		i_decodeMode.className = 'ghost';
		i_uploadSection.style.display = 'block';
		i_previewSection.style.display = i_previewSection.style.display; // keep as is
		i_directDecodeSection.style.display = 'none';
		btnEncodeImg.style.display = 'inline-flex';
		btnDecodeImg.style.display = 'inline-flex';
	});

	i_decodeMode.addEventListener('click', ()=> {
		I_currentMode = 'decode';
		i_uploadMode.className = 'ghost';
		i_decodeMode.className = 'secondary';
		i_uploadSection.style.display = 'none';
		i_previewSection.style.display = 'none';
		i_directDecodeSection.style.display = 'block';
		btnEncodeImg.style.display = 'none';
		btnDecodeImg.style.display = 'none';
		i_dnaSection.style.display = 'none';
	});

	// DNA input character counter
	i_dnaInput.addEventListener('input', ()=> {
		const cleaned = i_dnaInput.value.replace(/\s/g, '').toUpperCase();
		const validDNA = cleaned.replace(/[^ATCG]/g, '');
		i_dnaCharCount.textContent = `${validDNA.length} base${validDNA.length !== 1 ? 's' : ''}`;
		
		// Need at least 16 bases for dimensions (8 bytes = 4 bases per byte * 2 bytes * 2 dimensions)
		btnDecodeFromDNA.disabled = validDNA.length < 16;
	});

	// Reset image mapping
	i_resetMap.addEventListener('click', ()=> {
		iMap.A.value = '00';
		iMap.C.value = '01';
		iMap.G.value = '10';
		iMap.T.value = '11';
	});

	// File input change
	imgFile.addEventListener('change', ()=> {
		const file = imgFile.files && imgFile.files[0];
		if(file){
			i_fileInfo.textContent = `${file.name} (${(file.size/1024).toFixed(1)} KB)`;
		} else {
			i_fileInfo.textContent = 'No file selected';
		}
	});

	// Copy DNA
	i_copyDNA.addEventListener('click', async ()=> {
		if(I_currentDNA){
			await navigator.clipboard.writeText(I_currentDNA);
			i_copyDNA.textContent = '✓ Copied!';
			setTimeout(()=> i_copyDNA.textContent = '📋 Copy', 2000);
		}
	});

	// Download decoded image
	i_downloadImg.addEventListener('click', ()=> {
		const link = document.createElement('a');
		link.download = 'decoded_image.png';
		link.href = imgDecoded.toDataURL();
		link.click();
	});

	function loadImageToCanvas(file){
		return new Promise((resolve,reject)=>{
			const url = URL.createObjectURL(file);
			const img = new Image();
			img.onload = ()=>{
				const maxSide = 128; // limit for demo
				const scale = Math.min(maxSide/img.width, maxSide/img.height, 1);
				const w = Math.max(1, Math.floor(img.width*scale));
				const h = Math.max(1, Math.floor(img.height*scale));
				imgPreview.width = w; imgPreview.height = h; 
				iptx.drawImage(img, 0,0,w,h);
				URL.revokeObjectURL(url);
				resolve({w,h});
			};
			img.onerror = reject; img.src=url;
		});
	}

	btnLoadImg.addEventListener('click', async ()=>{
		i_error.textContent=''; 
		i_dnaSection.style.display = 'none';
		i_decodedSection.style.display = 'none';
		
		const file = imgFile.files && imgFile.files[0];
		if(!file){ i_error.textContent='Choose an image file first.'; return; }
		
		await showProcessing('Loading image…', 800);
		const {w, h} = await loadImageToCanvas(file);
		
		I_imageWidth = w;
		I_imageHeight = h;
		i_imgDimensions.textContent = `${w} × ${h} pixels`;
		i_previewSection.style.display = 'block';
		btnEncodeImg.disabled = false;
	});

	btnEncodeImg.addEventListener('click', async ()=>{
		i_error.textContent=''; 
		i_decodedSection.style.display = 'none';
		
		const m = getMappingsImage(); 
		const err = validateMappings(m); 
		if(err){ i_error.textContent=err; return; }
		
		const {width:w, height:h} = imgPreview;
		if(!w || !h){ i_error.textContent='Load an image preview first.'; return; }
		
		await showProcessing('Encoding image to DNA…', 1200);
		const data = iptx.getImageData(0,0,w,h).data;
		
		// Calculate expected size
		const pixelCount = w * h;
		const maxBits = pixelCount * 8; // 8 bits per pixel (grayscale)
		
		// Grayscale then to bits
		let bits='';
		for(let i=0;i<data.length;i+=4){
			const r=data[i], g=data[i+1], b=data[i+2];
			const y = Math.round(0.299*r + 0.587*g + 0.114*b); // 0..255
			const bin = y.toString(2).padStart(8,'0');
			bits += bin;
		}
		
		I_imageBits = bits;
		
		// Prepend width and height (16 bits each = 4 bases each)
		const widthBits = w.toString(2).padStart(16, '0');
		const heightBits = h.toString(2).padStart(16, '0');
		const headerBits = widthBits + heightBits;
		
		// Compress the image bits using RLE (Run-Length Encoding)
		let compressed = '';
		let currentBit = bits[0];
		let count = 1;
		
		for(let i = 1; i < bits.length; i++) {
			if(bits[i] === currentBit && count < 255) {
				count++;
			} else {
				// Store bit + count (1 bit + 8 bits = 9 bits, rounded to 10 for alignment)
				compressed += currentBit + count.toString(2).padStart(8, '0');
				currentBit = bits[i];
				count = 1;
			}
		}
		// Add the last run
		compressed += currentBit + count.toString(2).padStart(8, '0');
		
		// Add compression flag (1 bit) and use compressed if smaller
		let finalBits;
		if(compressed.length < bits.length) {
			finalBits = '1' + compressed.length.toString(2).padStart(31, '0') + headerBits + compressed;
		} else {
			finalBits = '0' + '0'.repeat(31) + headerBits + bits;
		}
		
		// Map to DNA
		const R = revMap(m);
		let dna='';
		for(let i=0;i<finalBits.length;i+=2){ 
			const base = R[finalBits.substr(i,2)]; 
			if(!base) break; 
			dna += base; 
		}
		
		I_currentDNA = dna;
		i_dnaOut.textContent = dna.length > 500 ? dna.slice(0,500) + '...' : dna;
		i_baseCount.textContent = `${dna.length} base${dna.length !== 1 ? 's' : ''}`;
		i_dnaSection.style.display = 'block';
		btnDecodeImg.disabled = false;
	});

	btnDecodeImg.addEventListener('click', async ()=> {
		i_error.textContent='';
		
		const m = getMappingsImage(); 
		const err = validateMappings(m); 
		if(err){ i_error.textContent=err; return; }
		
		if(!I_currentDNA){ i_error.textContent='Encode an image first.'; return; }
		
		await showProcessing('Decoding DNA to image…', 1200);
		
		// Convert DNA back to bits
		const allBits = dnaToBits(I_currentDNA, m);
		
		// Check compression flag (first bit)
		const isCompressed = allBits[0] === '1';
		let imageBits;
		
		if(isCompressed) {
			// Extract compressed length
			const compressedLength = parseInt(allBits.substr(1, 31), 2);
			const widthBits = allBits.substr(32, 16);
			const heightBits = allBits.substr(48, 16);
			const w = parseInt(widthBits, 2);
			const h = parseInt(heightBits, 2);
			const compressedData = allBits.substr(64, compressedLength);
			
			// Decompress RLE
			imageBits = '';
			for(let i = 0; i < compressedData.length; i += 9) {
				const bit = compressedData[i];
				const count = parseInt(compressedData.substr(i + 1, 8), 2);
				imageBits += bit.repeat(count);
			}
			
			// Reconstruct image
			imgDecoded.width = w;
			imgDecoded.height = h;
			
			const imageData = idtx.createImageData(w, h);
			const pixelCount = w * h;
			
			for(let i=0; i<pixelCount; i++){
				const bitStart = i * 8;
				const byte = imageBits.substr(bitStart, 8);
				if(byte.length === 8){
					const gray = parseInt(byte, 2);
					const dataIndex = i * 4;
					imageData.data[dataIndex] = gray;
					imageData.data[dataIndex+1] = gray;
					imageData.data[dataIndex+2] = gray;
					imageData.data[dataIndex+3] = 255;
				}
			}
			
			idtx.putImageData(imageData, 0, 0);
		} else {
			// Uncompressed - original method
			const widthBits = allBits.substr(32, 16);
			const heightBits = allBits.substr(48, 16);
			const w = parseInt(widthBits, 2);
			const h = parseInt(heightBits, 2);
			imageBits = allBits.substr(64);
			
			imgDecoded.width = w;
			imgDecoded.height = h;
			
			const imageData = idtx.createImageData(w, h);
			const pixelCount = w * h;
			
			for(let i=0; i<pixelCount; i++){
				const bitStart = i * 8;
				const byte = imageBits.substr(bitStart, 8);
				if(byte.length === 8){
					const gray = parseInt(byte, 2);
					const dataIndex = i * 4;
					imageData.data[dataIndex] = gray;
					imageData.data[dataIndex+1] = gray;
					imageData.data[dataIndex+2] = gray;
					imageData.data[dataIndex+3] = 255;
				}
			}
			
			idtx.putImageData(imageData, 0, 0);
		}
		
		i_decodedSection.style.display = 'block';
	});

	// Decode from DNA input (direct mode)
	btnDecodeFromDNA.addEventListener('click', async ()=> {
		i_error.textContent='';
		i_decodedSection.style.display = 'none';
		
		const m = getMappingsImage(); 
		const err = validateMappings(m); 
		if(err){ i_error.textContent=err; return; }
		
		const dnaInput = i_dnaInput.value.replace(/\s/g, '').toUpperCase().replace(/[^ATCG]/g, '');
		if(!dnaInput){ i_error.textContent='Please enter a valid DNA sequence.'; return; }
		
		if(dnaInput.length < 16){
			i_error.textContent='DNA sequence too short. Need at least 16 bases for image dimensions.';
			return;
		}
		
		await showProcessing('Decoding DNA to image…', 1200);
		
		// Convert DNA back to bits
		const allBits = dnaToBits(dnaInput, m);
		
		// Check compression flag (first bit)
		const isCompressed = allBits[0] === '1';
		let w, h, imageBits;
		
		if(isCompressed) {
			// Extract compressed length
			const compressedLength = parseInt(allBits.substr(1, 31), 2);
			const widthBits = allBits.substr(32, 16);
			const heightBits = allBits.substr(48, 16);
			w = parseInt(widthBits, 2);
			h = parseInt(heightBits, 2);
			const compressedData = allBits.substr(64, compressedLength);
			
			if(!w || !h || w <= 0 || h <= 0 || w > 512 || h > 512){ 
				i_error.textContent=`Invalid image dimensions detected: ${w}×${h}. DNA may be corrupted.`; 
				return; 
			}
			
			// Decompress RLE
			imageBits = '';
			for(let i = 0; i < compressedData.length; i += 9) {
				const bit = compressedData[i];
				const count = parseInt(compressedData.substr(i + 1, 8), 2);
				imageBits += bit.repeat(count);
			}
		} else {
			// Uncompressed - original method
			const widthBits = allBits.substr(32, 16);
			const heightBits = allBits.substr(48, 16);
			w = parseInt(widthBits, 2);
			h = parseInt(heightBits, 2);
			
			if(!w || !h || w <= 0 || h <= 0 || w > 512 || h > 512){ 
				i_error.textContent=`Invalid image dimensions detected: ${w}×${h}. DNA may be corrupted.`; 
				return; 
			}
			
			imageBits = allBits.substr(64);
		}
		
		const expectedBits = w * h * 8;
		if(imageBits.length < expectedBits){
			i_error.textContent=`DNA sequence incomplete for ${w}×${h} image. Got ${imageBits.length} bits, need ${expectedBits}.`;
			return;
		}
		
		// Reconstruct image
		imgDecoded.width = w;
		imgDecoded.height = h;
		
		const imageData = idtx.createImageData(w, h);
		const pixelCount = w * h;
		
		for(let i=0; i<pixelCount; i++){
			const bitStart = i * 8;
			const byte = imageBits.substr(bitStart, 8);
			if(byte.length === 8){
				const gray = parseInt(byte, 2);
				const dataIndex = i * 4;
				imageData.data[dataIndex] = gray;
				imageData.data[dataIndex+1] = gray;
				imageData.data[dataIndex+2] = gray;
				imageData.data[dataIndex+3] = 255;
			}
		}
		
		idtx.putImageData(imageData, 0, 0);
		i_decodedSection.style.display = 'block';
	});

	// Initialize default view
	showView(introView);
	</script>
</body>
</html>

